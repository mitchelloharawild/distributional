% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{get_transform}
\alias{get_transform}
\alias{get_inverse}
\alias{get_deriv}
\alias{seq_apply}
\title{Extract functions from a transformed distribution}
\usage{
get_transform(x)

get_inverse(x)

get_deriv(x)

seq_apply(fun_list, values)
}
\arguments{
\item{x}{A distribution object}

\item{fun_list}{A list of functions to apply in sequence to a vector of values}

\item{values}{A vector of values to apply the functions to. \code{values} will be
passed to the first function in \code{fun_list}, and the result will be passed to
the next function, and so on.}
}
\value{
A list of lists of functions. Each list corresponds to one distribution
in a distribution vector. Each list contains the functions for the transformations,
inverses, and derivatives applied to the distribution. The entries are sorted
in the reverse order of application.
}
\description{
\code{\link[=get_transform]{get_transform()}}, \code{\link[=get_inverse]{get_inverse()}}, and \code{\link[=get_deriv]{get_deriv()}} are used to extract
a list of functions from a transformed distribution. \code{\link[=seq_apply]{seq_apply()}} can be
used to apply the functions in sequence to a vector of values.
}
\examples{
# transform a uniform distribution into a gumbel distribution
dist <- -log(-log(dist_uniform(0, 1)))

# extract the functions from the transformed distribution
(transforms <- get_transform(dist)[[1]])
(inverses <- get_inverse(dist)[[1]])
(derivatives <- get_deriv(dist)[[1]])

# apply the functions in sequence
res <- seq_apply(rev(transforms), 0.5) # use rev() to apply in the correct order
inv <- seq_apply(inverses, res)
identical(inv, 0.5)

# manually calculate the density of the transformed distribution using the chain rule
n <- length(derivatives)
value <- 0
inv <- seq_apply(inverses, value)
res <- derivatives[[1]](value)
if (n > 1) {
  for (i in 2:n) {
    value <- inverses[[i-1]](value)
    res <- res * derivatives[[i]](value)
  }
}

identical(density(dist_uniform(0, 1), inv)[[1]] * res, density(dist, 0))
}
